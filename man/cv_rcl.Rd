% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv_rcl.R
\name{cv_rcl}
\alias{cv_rcl}
\title{Cross-Validated Regression-Calibrated Lasso}
\usage{
cv_rcl(me_list, Lambda, ...)
}
\arguments{
\item{me_list}{List containing, at the very least, the number of replicates, k, the response y, a list of k matrices of error-prone observations W -- one for each replicate, and a matrix of error-free predictors Z if one desires to include it in the model.}

\item{Lambda}{Reliability matrix (or its estimate, if unknown).}

\item{...}{Inputs to the cv.glmnet function.}
}
\value{
An object of class "cv.glmnet".
}
\description{
Cross-validation for RC Lasso for linear or logistic regression.
}
\examples{
if(!require("glasso")){
  stop("this example requires package 'glasso'")
}

set.seed(1424)

n <- 300
p <- 500
s <- 10 # number of non-zero coefficients
k <- 5

sig2x <- 1
sig2u <- 1
Sig_x <- choose_matrix(sig2x, rho=0.7, p=p, blk_sz=20, structure="diag")
Sig_u <- choose_matrix(k*sig2u, rho=0, p=p, structure="diag")

mu <- 100
mu_x <- rep(5, p)

# randomly sample sparsity index set.
S <- sample(1:p, s, replace=FALSE)
beta <- rep(0, p); beta[S] <- 2
data <- data_gen(n=n, p=p, k=k, mu=mu, mu_x=mu_x, beta=beta, Sig_x=Sig_x, Sig_u=Sig_u)

# average of replicates
W_bar <- Reduce('+', data$W) / k
# use Graphical Lasso (Friedman et al., 2008)
gl <- glasso::glasso(cov(W_bar), rho=0.2)

# estimate Sig_u, a diagonal matrix
svar2u <- rep(0, p)
for (i in 1:p){
  for (j in 1:k){
    svar2u[i] <- svar2u[i] + sum( (data$W[[j]][,i] - W_bar[,i])^2 )
  }
}
svar2u <- svar2u / (n*(k-1))
SCov_uu <- diag(svar2u)

# estimate reliability matrix
Lambda <- gl$wi \%*\% (gl$w - SCov_uu/k)

# cross-validated RC Lasso
cv.rcl.fit <- cv_rcl(data, Lambda, family="gaussian", intercept=TRUE,
                     standardize=TRUE, nfolds=10)
# for comparison, cross-validated Naive Lasso (i.e. no measurement error correction)
cv.nl.fit <- glmnet::cv.glmnet(W_bar, data$y, family="gaussian", intercept=TRUE,
                               standardize=TRUE, nfolds=10)
# get estimated intercept from cross-validated 1se lambda
muRC_hat <- as.matrix(coef(cv.rcl.fit, s=cv.rcl.fit$lambda.1se))[1]
muNL_hat <- as.matrix(coef(cv.nl.fit, s=cv.nl.fit$lambda.1se))[1]
# get estimated coefficients from cross-validated 1se lambda
betaRC_hat <- as.matrix(coef(cv.rcl.fit, s=cv.rcl.fit$lambda.1se))[2:(p+1)]
betaNL_hat <- as.matrix(coef(cv.nl.fit, s=cv.nl.fit$lambda.1se))[2:(p+1)]
}
